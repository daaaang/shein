# 카프카 정리

<br/>

## 1. 간단한 사례

- 카프카는 링크드인에서 개발
- 잘란도의 사례
    - 이벤트 드리븐 시스템 아키텍처로 변화 중 인바운드 데이터 및 아웃바운드 데이터의 동일성 문제 발생
    - 비동기 방식의 대표 스트리밍 카프카 도입
- 트위터 카프카 사례
  - 사용자의 글은 팔로우하는 유저에게 메세지가 즉시 전달
  - 최초 카프카 선택 -> 카프카 장애 발생하여 이벤트 버스 방식 채택 -> 카프카 성능 향상 후 다시 카프카 선택
    - cf: 이벤트 버스 방식 -  다양한 컴포넌트, 서비스, 애플리케이션 간에 메시지나 이벤트를 전송하는 데 사용되는 디자인 패턴 및 소프트웨어 아키텍처 구성 요소
  - 카프카로 다시 변환 후 BPS(자료 전달 속도)와 상관없이 지연이 거의 발생하지 않음
  - 카프카는 OS에 의존해 백그라운드로 fsync()를 처리하고 제로 카피
    - fsync() 유닉스 운영체제에서 사용하는 시스템 콜, 데이터를 디스크에 쓰도록 강제
  - 제로카피: 데이터를 복사하는 프로세스 없이 데이터를 한 위치에서 다른 위치로 이동하는 최적화된 데이터 전송 기술

<br/>

## 2. 카프카 특징

- 순서 보장
    - 이벤트 처리 순서가 보장되면서, 엔티티 간의 유효성 검사나 동시 수정 같은 무수한 복잡성들이 제거됨
- 적어도 한 번 전송 방식
    - 멱등성: 동일한 작업을 여러 번 수행하더라도 결과가 달라지지 않는 것
    - 프로듀서가 재전송을 하더라도 데이터 변화는 일어나지 않음
    - 적어도 한 번 전송 방식
- 자연스러운 백프레셔 핸들링
    - 백프레셔
      - 일반적으로 데이터 처리 시스템에서 발생할 수 있는 현상, 퍼리 능력을 초고하는 속도로 데이터가 들어오면서 발생
      - 데이터 유입을 일시적으로 제한, 조절하는 매커니즘
    - 풀 방식으로 동작
    - 자기 자신의 속도로 데이터를 처리할 수 있음
      - 컨슈머가 동작이 가능할 떄 데이터를 처리할 수 있음
- 강력한 파티셔닝
  - 논리적으로 토픽을 나눌 수 있음
- 고가용성
- 개발 편의성
  - 카프카는 메세지를 전송하는 역할은 프로듀서와 메세지를 가져오는 역할을 하는 컨슈머가 완벽하게 분리되어 동작
  - 서로 영향을 주지 않음
  - 개발 편의성을 제공하기 위해 카프카에서는 카프카 커넥트와 스키마 레지스트리를 제공
  - 카프카를 사용하는 많은 개발자가 데이터를 활용하기 보다 데이터를 파싱하는데 많은 시간을 소모하는데 매우 비효율적인 현실을 보완
  - 스키마를 정의해서 사용할 수 있도록 개발된 애플리케이션...?
  
<br/>


## 3. 카프카 기본 개념과 구조
- 카프카를 구성하는 주요 요소
  - 주키퍼: 아파티 프로젝트 애플리케이션 이름
  - 카프카의 메타데이터 관리 및 브로커의 정상상태 점검을 담당
- 카프카 또는 카프카 클러스터: 아파티 프로젝트 애플리케이션 이름, 여러 대의 브로커를 구성한 클러스터를 의미
- 브로커: 카프카 애플리케이션이 설치된 서버 또는 노드
- 프로듀서: 카프카로 메세지를 보내는 역할을 하는 클라이언트 총칭
- 컨슈머: 카프케에서 메세지를 꺼내는 역할을 하는 클라이언트를 총칭
- 토픽: 카프카는 메세지 피드들을 토픽으로 구분하고, 각 토픽의 이름은 카프카 내에서 공유
- 파티션: 병렬 처리 및 고성능을 얻기 위해 토픽을 여러 개로 나눈 것을 의미
- 세그먼트: 프로듀서가 전송한 실제 메세지가 브로커의 로컬 디스크에 저장되는 파일을 의미
- 메세지 또는 레코드: 프로듀서가 브로커를 전송하거나 컨슈머가 읽어가는 데이터 조각을 의미

## 4. 리플리케이션
